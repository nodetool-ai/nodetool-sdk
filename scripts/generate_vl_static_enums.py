from __future__ import annotations

import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Iterable


@dataclass(frozen=True)
class EnumDef:
    type_name: str
    values: list[str]


# Minimal C# keyword list (covers collisions like "as", "is", "in", "int", "long", "short", "goto", etc.)
CSHARP_KEYWORDS: set[str] = {
    "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
    "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
    "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
    "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
    "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
    "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short",
    "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true",
    "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual",
    "void", "volatile", "while",
}


def _sanitize_identifier(s: str) -> str:
    s = re.sub(r"[^0-9A-Za-z_]", "_", s)
    s = re.sub(r"_+", "_", s).strip("_")
    if not s:
        return "Enum"
    if s[0].isdigit():
        s = "E_" + s
    if s in CSHARP_KEYWORDS:
        s = "v_" + s
    return s


def _enum_class_name(type_name: str) -> str:
    parts = [p for p in type_name.split(".") if p]
    if len(parts) >= 2:
        base = f"{parts[-2]}_{parts[-1]}"
    else:
        base = parts[-1] if parts else "Enum"
    return _sanitize_identifier(base)


def _extract_enums(obj: Any) -> Iterable[EnumDef]:
    if isinstance(obj, dict):
        # NodeTypeDefinition-like shape: { type:"enum", values:[...], type_name:"..." }
        t = obj.get("type")
        if t == "enum" and isinstance(obj.get("values"), list) and isinstance(obj.get("type_name"), str):
            values = [str(v) for v in obj["values"]]
            yield EnumDef(type_name=obj["type_name"], values=values)

        for v in obj.values():
            yield from _extract_enums(v)
    elif isinstance(obj, list):
        for v in obj:
            yield from _extract_enums(v)


def _load_enum_defs(metadata_paths: list[Path]) -> list[EnumDef]:
    enums: dict[str, EnumDef] = {}
    for path in metadata_paths:
        data = json.loads(path.read_text(encoding="utf-8"))
        for enum_def in _extract_enums(data):
            # Keep first occurrence; all packages should agree on values for same type_name.
            enums.setdefault(enum_def.type_name, enum_def)
    return sorted(enums.values(), key=lambda e: e.type_name.lower())


def _find_package_metadata_jsons(repo_root: Path) -> list[Path]:
    # Expect nodetool-sdk checked out alongside nodetool-base/core/etc under a common parent directory.
    parent = repo_root.parent
    candidates = sorted(parent.glob("nodetool-*/src/nodetool/package_metadata/*.json"))
    if not candidates:
        raise SystemExit(f"No package_metadata JSON files found under {parent}")
    return candidates


def _render_enums_cs(enums: list[EnumDef]) -> str:
    lines: list[str] = []
    lines.append("// <auto-generated />")
    lines.append("namespace Nodetool.SDK.VL.Enums.Generated;")
    lines.append("")

    used_class_names: set[str] = set()
    for enum_def in enums:
        class_name = _enum_class_name(enum_def.type_name)
        if class_name in used_class_names:
            # Extremely rare collision; disambiguate deterministically using a stable suffix.
            # (Do NOT use Python's hash(), it is randomized per process by default.)
            suffix = re.sub(r"[^0-9a-f]", "", enum_def.type_name.encode("utf-8").hex())[:8] or "dup"
            class_name = f"{class_name}_{suffix}"
        used_class_names.add(class_name)

        lines.append(f"// {enum_def.type_name}")
        lines.append(f"public enum {class_name}")
        lines.append("{")
        used_members: set[str] = set()
        for i, v in enumerate(enum_def.values):
            member = _sanitize_identifier(v.lower())
            # ensure unique members
            if member == "Enum":
                member = f"Value_{i}"
            if member in used_members:
                member = f"{member}_{i}"
            used_members.add(member)
            lines.append(f"    {member} = {i},")
        lines.append("}")
        lines.append("")

    return "\n".join(lines)


def _render_registry_cs(enums: list[EnumDef]) -> str:
    lines: list[str] = []
    lines.append("// <auto-generated />")
    lines.append("using System;")
    lines.append("using System.Collections.Generic;")
    lines.append("using Nodetool.SDK.VL.Enums.Generated;")
    lines.append("")
    lines.append("namespace Nodetool.SDK.VL.Utilities;")
    lines.append("")
    lines.append("internal static partial class StaticEnumRegistry")
    lines.append("{")
    lines.append("    internal sealed record EnumInfo(Type EnumType, IReadOnlyDictionary<string, int> IndexByValue, IReadOnlyDictionary<int, string> ValueByIndex);")
    lines.append("")
    lines.append("    private static readonly Dictionary<string, EnumInfo> ByTypeName = new(StringComparer.OrdinalIgnoreCase)")
    lines.append("    {")

    for enum_def in enums:
        class_name = _enum_class_name(enum_def.type_name)
        values = enum_def.values
        # string->int map uses original literal strings as keys.
        # Deduplicate keys (keep first index) to avoid runtime "duplicate key" exceptions.
        seen_keys: set[str] = set()
        idx_pairs: list[tuple[str, int]] = []
        for i, v in enumerate(values):
            if v in seen_keys:
                continue
            seen_keys.add(v)
            idx_pairs.append((v, i))
        idx_entries = ", ".join([f'{{ "{v}", {i} }}' for v, i in idx_pairs])
        val_entries = ", ".join([f"{{ {i}, \"{v}\" }}" for i, v in enumerate(values)])
        lines.append(f'        ["{enum_def.type_name}"] = new EnumInfo(typeof({class_name}),')
        lines.append(f"            new Dictionary<string, int>(StringComparer.Ordinal) {{ {idx_entries} }},")
        lines.append(f"            new Dictionary<int, string> {{ {val_entries} }}),")

    lines.append("    };")
    lines.append("")
    lines.append("    internal static bool TryGetEnumTypeByName(string typeName, out Type enumType)")
    lines.append("    {")
    lines.append("        enumType = null!;")
    lines.append("        return ByTypeName.TryGetValue(typeName, out var info) && (enumType = info.EnumType) != null;")
    lines.append("    }")
    lines.append("")
    lines.append("    internal static bool TryGetEnumInfo(Type enumType, out EnumInfo info)")
    lines.append("    {")
    lines.append("        foreach (var kvp in ByTypeName)")
    lines.append("        {")
    lines.append("            if (kvp.Value.EnumType == enumType)")
    lines.append("            {")
    lines.append("                info = kvp.Value;")
    lines.append("                return true;")
    lines.append("            }")
    lines.append("        }")
    lines.append("        info = null!;")
    lines.append("        return false;")
    lines.append("    }")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    metadata_paths = _find_package_metadata_jsons(repo_root)
    enums = _load_enum_defs(metadata_paths)

    enums_cs = _render_enums_cs(enums)
    registry_cs = _render_registry_cs(enums)

    enums_out = repo_root / "csharp" / "Nodetool.SDK.VL" / "Enums" / "Generated" / "NodeToolEnums.g.cs"
    reg_out = repo_root / "csharp" / "Nodetool.SDK.VL" / "Utilities" / "StaticEnumRegistry.Generated.cs"
    enums_out.parent.mkdir(parents=True, exist_ok=True)

    enums_out.write_text(enums_cs, encoding="utf-8")
    reg_out.write_text(registry_cs, encoding="utf-8")

    print(f"Wrote {enums_out}")
    print(f"Wrote {reg_out}")
    print(f"Total enums: {len(enums)}")


if __name__ == "__main__":
    main()


